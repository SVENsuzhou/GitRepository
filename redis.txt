Redis作为一个高性能的内存数据库，在实际应用中可以很好的解决cache，数据共享等问题。但客户端采用hiredis的时候，需要注意几点：
1.对于block方式的操作：在block操作模式下，每个命令都是单独发向Redis的，且也会等待每个的结果返回。即，通过redisCommand调用，即完成了向Redis发送命
令，也等待Redis返回结果。换言之，是一个阻塞的过程。如果在是并发量比较高的情况下，此种方式，会使得客户端效率较差。即便是将Redis部署在本地，通过
local进行访问，也会有0.02毫秒级别的等待过程。如果客户端有很多次的访问操作，每次都会阻塞一小段时间，会使得客户端本身的处理速度降下来。为了降低这
种开销，可以采用pipeline的方式。也即一次向Redis发送多个命令。将这多个命令发送完毕后，再进行统一处理。当然，这样的代价是客户端的发送缓冲区会变大，
接收缓冲区也会变大。但处理的吞吐量会增加。
2.对于non-block方式的操作：在这种模式下，默认的调用redisCommand就会立即返回，相当于block模式下显式的调用AppendCommand。不过在这种模式下，要显示的
调用获取回应的replay，然后将reply释放掉，以免造成内存泄漏。
上面说的，都是同步的操作过程。操作过程和客户端的程序是在一个进程里完成的。另外还可以采用异步的方式。



排行榜
游戏服务器中涉及到很多排行信息，比如玩家等级排名、金钱排名、战斗力排名等。
一般情况下仅需要取排名的前N名就可以了，这时可以利用数据库的排序功能，或者自己维护一个元素数量有限的top集合。
但是有时候我们需要每一个玩家的排名，玩家的数量太多，不能利用数据库（全表排序压力太大），自己维护也会比较麻烦。
使用Redis可以很好的解决这个问题。它提供的有序Set，支持每个键值（比如玩家id）拥有一个分数（score），每次往这个set里添加元素，
Redis会对其进行排序，修改某一元素的score后，也会更新排序，在获取数据时，可以指定排序范围。
更重要的是，这个排序结果会被保存起来，不用在服务器启动时重新计算。
通过它，排行榜的实时刷新、全服排行都不再成为麻烦事。


消息队列（可跨服）
Redis提供的List数据类型，可以用来实现一个消息队列。
由于它是独立于游戏服务器的，所以多个游戏服务器可以通过它来交换数据、发送事件。
Redis还提供了发布、订阅的事件模型。
利用这些，我们就不必自己去实现一套服务器间的通信框架，方便地实现服务器组。


数据库缓存
Redis提供了较为丰富数据类型，使我们可以更为容易地将数据对象缓存起来（序列化、protobuffer）。
当需要请求某一数据时，先从Redis中查找，如果没有再查数据库，同时交给Redis缓存起来。
当对数据进行修改时，则先将修改后的数据保存到Redis，然后保存至数据库（2）。
第2步可以有另外的思路：
   A 不实时保存到数据库，而是交由另外的线程（甚至是专门的程序）去保存，以提高逻辑层的响应速度。
   B 部分数据交给Redis保存（Reids自身有持久化功能），像玩家已经完成过的任务ID集合，利用Redis的Set类型保存更为合适。
   C 玩家瞬时变化的数据不见得每次修改都需要保存（比如金钱、经验），但如果游戏服务器自己维护在内存中，出现宕机就会导致回档。
Redis是独立于游戏服务器的，交由它来保存，可以防止宕机回档的问题，也可以减少游戏服务器自己维护数据所占用的内存。





使用aof代替snapshot
Redis有两种存储方式，默认是snapshot方式，实现方法是定时将内存的快照(snapshot)持久化到硬盘，这种方法缺点是持久化之后如果出现crash则会丢失一段数据。
因此在完美主义者的推动下作者增加了aof方式。aof即append only mode，在写入内存数据的同时将操作命令保存到日志文件，在一个并发更改上万的系统中，命令日
志是一个非常庞大的数据，管理维护成本非常高，恢复重建时间会非常长，这样导致失去aof高可用性本意。另外更重要的是Redis是一个内存数据结构模型，所有的优
势都是建立在对内存复杂数据结构高效的原子操作上，这样就看出aof是一个非常不协调的部分。

其实aof目的主要是数据可靠性及高可用性，在Redis中有另外一种方法来达到目的：Replication。由于Redis的高性能，复制基本没有延迟。这样达到了防止单点故障及实现了高可用。



应用

 

1）读取缓存。使用set、get和expire命令。每次从数据库中读取某个值时，将该值set进redis中，并使用expire设置超时时间，之后，再次读取该值时，直接从redis中get出来

2）新鲜事（游戏角色动态）。使用rpush、ltrim和lrange。后端程序使用rpush新值，然后ltrim最旧的值。前端程序lrange分页出需要的动态。

3）状态一致性。每个接收端都sub状态，pub进最新的状态；或者使用set最新状态，get出最新状态。

 

陷阱

 

1）读取缓存。有可能get出错误的值，比如，我曾经get某个值时，get出了INFO命令的结果。

2）新鲜事（游戏角色动态）。由于redis不支持key的LRU算法，当内存撑满到设置的内存最大的阀值，不能将调用最少的键值给删除掉。redis不支持list的每个value的expire。我曾经想过每次使用rpush后设置expire，这样就可以将长时间不玩游戏的玩家的“旧事”从redis中干掉。但是测试后发现，在expire后，使用rpush，会将之前rpush的数据给删除掉，而v2.0.4版本不能使用persist命令去掉expire。目前我们只能加硬件和降低cache每个角色的动态数量。

3）状态一致性。如果使用pub/sub模式，sub端需要有一个线程阻塞等待sub；如果使用set/get模式，get端需要timer线程定时get出最新状态。

4）VM问题。由于成本问题，我们被迫使用VM，当内存不够时，将某些key的值存入VM中。但是VM在v2.0.4有很多问题，首先是影响性能，导致取数据非常缓慢。另外有可能照成redis-server宕机。



DELIMITER $$
CREATE TRIGGER datatoredis AFTER UPDATE ON test FOR EACH ROW BEGIN
    SET @ret=gman_do_background('syncToRedis', json_object(NEW.id as `id`, NEW.name as `name`)); 
  END$$
DELIMITER ;




Redis是一个key-value存储系统。和Memcached类似，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。在部分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby等客户端，使用很方便。

yum -y install nginx php php-fpm php-cli php-common php-gd php-mbstring php-mysql php-pdo php-devel php-xmlrpc php-xml php-bcmath php-dba php-enchant mysql mysql-server

[root@redis ~]# sed -i 's/apache/nginx/g' /etc/php-fpm.d/www.conf
[root@redis ~]# /etc/init.d/php-fpm start
正在启动 php-fpm：                                         [确定]
[root@redis ~]# /etc/init.d/mysqld start
正在启动 mysqld：                                          [确定]
[root@redis ~]# mkdir /{logs,www}
[root@redis ~]# chown -R nginx:nginx /{logs,www}
[root@redis ~]# /etc/init.d/nginx start
正在启动 nginx：                                           [确定]
[root@redis www]# service iptables stop
iptables: Flushing firewall rules:                         [  OK  ]
iptables: Setting chains to policy ACCEPT: filter          [  OK  ]
iptables: Unloading modules:                               [  OK  ]


[root@redis ~]# wget -c -t 0 http://download.redis.io/releases/redis-2.8.19.tar.gz
[root@redis ~]# mkdir /usr/local/redis
[root@redis ~]# tar xvf redis-2.8.19.tar.gz 
[root@redis ~]# cd redis-2.8.19
[root@redis src]# cp redis-benchmark redis-check-aof redis-check-dump redis-cli redis-sentinel redis-server /usr/local/redis/
[root@redis redis-2.8.19]# cp redis.conf sentinel.conf /usr/local/redis/


Redis-benchmark      压力测试工具
Redis-check-aof      检查redis持久化命令文件的完整性
Redis-check-dump     检查redis持久化数据文件的完整性
Redis-cli            redis在linux上的客户端
Redis-sentinel       redis-sentinel是集群管理工具,主要负责主从切换。
Redis-server         Redis服务器的daemon启动程序


[root@redis ~]# wget -c -t 0 https://github.com/owlient/phpredis/archive/master.zip
[root@redis ~]# unzip master.zip
[root@redis ~]# cd phpredis-master/
[root@redis phpredis-master]# phpize 
[root@redis phpredis-master]# ./configure --with-php-config=/usr/bin/php-config
[root@redis phpredis-master]# make && make install 
[root@redis ~]# vim /etc/php.ini 
extension=redis.so
[root@redis ~]# /etc/init.d/php-fpm restart
停止 php-fpm：                                             [确定]
正在启动 php-fpm：                                         [确定]

[root@redis ~]# cd /usr/local/redis/
[root@redis redis]# vim redis.conf
daemonize yes
[root@redis redis]# ./redis-server redis.conf



mysql> create database mytest;
mysql> CREATE TABLE `test` (`id` int(7) NOT NULL AUTO_INCREMENT, `name` char(8) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;
mysql> INSERT INTO `test` VALUES (1,'sven'),(2,'jim'),(3,'zhu'),(4,'wang'),(5,'ftd'),(6,'test'),(7,'test01'),(8,'test02'),(9,'test03');


Gearman是一个支持分布式的任务分发框架：
   Gearman Job Server：Gearman核心程序，需要编译安装并以守护进程形式运行在后台。
   Gearman Client：可以理解为任务的请求者。
   Gearman Worker：任务的真正执行者，一般需要自己编写具体逻辑并通过守护进程方式运行，Gearman Worker接收到Gearman Client传递的任务内容后，会按顺序处理。
   
   
[root@redis ~]# yum -y install gearmand libgearman-devel


/root/gearman-1.0.2/php_gearman.c: 在函数‘zif_gearman_job_send_data’中:
/root/gearman-1.0.2/php_gearman.c:1486: 错误：提领指向不完全类型的指针
/root/gearman-1.0.2/php_gearman.c: 在函数‘zif_gearman_job_send_warning’中:
/root/gearman-1.0.2/php_gearman.c:1514: 错误：提领指向不完全类型的指针
/root/gearman-1.0.2/php_gearman.c: 在函数‘zif_gearman_job_send_status’中:
/root/gearman-1.0.2/php_gearman.c:1537: 错误：提领指向不完全类型的指针


[root@redis ~]# wget -c -t 0 https://pecl.php.net/get/gearman-1.1.1.tgz
[root@redis ~]# tar xvf gearman-1.1.1.tgz 
[root@redis ~]# cd gearman-1.1.1
[root@redis gearman-1.1.1]# phpize 
[root@redis gearman-1.1.1]# ./configure --with-php-config=/usr/bin/php-config
[root@redis gearman-1.1.1]# make 
[root@redis gearman-1.1.1]# make install
[root@redis ~]# vim /etc/php.ini 
extension = "gearman.so"
[root@redis ~]# /etc/init.d/php-fpm restart
停止 php-fpm：                                             [确定]
正在启动 php-fpm：                                         [确定]


安装lib_mysqludf_json
[root@redis ~]# wget -c -t 0 https://github.com/mysqludf/lib_mysqludf_json/archive/master.zip
[root@redis ~]# unzip master.zip 
[root@redis ~]# cd lib_mysqludf_json-master/
[root@redis lib_mysqludf_json-master]# gcc $(mysql_config --cflags) -shared -fPIC -o lib_mysqludf_json.so lib_mysqludf_json.c
lib_mysqludf_json.c:40:23: 错误：my_global.h：没有那个文件或目录
lib_mysqludf_json.c:41:20: 错误：my_sys.h：没有那个文件或目录
lib_mysqludf_json.c:43:19: 错误：mysql.h：没有那个文件或目录
lib_mysqludf_json.c:44:21: 错误：m_ctype.h：没有那个文件或目录
lib_mysqludf_json.c:45:22: 错误：m_string.h：没有那个文件或目录
[root@redis lib_mysqludf_json-master]# yum -y install mysql-devel
[root@redis lib_mysqludf_json-master]# gcc $(mysql_config --cflags) -shared -fPIC -o lib_mysqludf_json.so lib_mysqludf_json.c

mysql> show global variables like 'plugin_dir';
+---------------+-------------------------+
| Variable_name | Value                   |
+---------------+-------------------------+
| plugin_dir    | /usr/lib64/mysql/plugin |
+---------------+-------------------------+

[root@redis lib_mysqludf_json-master]# cp lib_mysqludf_json.so /usr/lib64/mysql/plugin/

mysql> CREATE FUNCTION json_object RETURNS STRING SONAME 'lib_mysqludf_json.so';


[root@redis ~]# wget -c -t 0 https://launchpad.net/gearman-mysql-udf/trunk/0.6/+download/gearman-mysql-udf-0.6.tar.gz
[root@redis ~]# tar xvf gearman-mysql-udf-0.6.tar.gz
[root@redis ~]# cd gearman-mysql-udf-0.6
[root@redis gearman-mysql-udf-0.6]# ./configure --with-mysql=/usr/bin/mysql_config --libdir=/usr/lib64/mysql/plugin/
[root@redis gearman-mysql-udf-0.6]# make 
[root@redis gearman-mysql-udf-0.6]# make install 

安装gearman-mysql-udf


mysql> set @RECV = 1;
mysql> select @RECV;
+------+
| @RECV|
+------+
|    1 |
+------+
mysql> update test set name = 'ssss' where id = 1;
mysql> select @RECV;
+------+
| @RECV|
+------+
| NULL |
+------+


[root@redis redis]# ./redis-cli 
127.0.0.1:6379> get 1
"{\"id\":1,\"name\":\"ssss\"}"


+--------------------+
| Database           |
+--------------------+
| LOGGER_68WW01_07   |
| LOGGER_68WW08_16   |
| LOGGER_68WW17_25   |
| LOGGER_68WW26_34   |
| LOGGER_68WW353637  |
| LOGGER_68WW383940  |
| LOGGER_68WW414243  |
| LOGGER_68WW44      |
| LOGGER_68WW45      |
| LOGGER_68WW46      |
| LOGGER_68WW47      |
| LOGGER_68WW48      |
| LOGGER_68WW49      |
| LOGGER_68WW50      |
| LOGGER_68WW51      |
| LOGGER_68WW52      |
| LOGGER_68WW53      |
| LOGGER_68WW54      |
| LOGGER_68WW55      |
| LOGGER_68WW56      |
| LOGGER_68WW57      |
+--------------------+


lib_mysqludf_json UDF库函数将关系数据映射为JSON格式。
通常，数据库中的数据映射为JSON格式，是通过程序来转换的。

触发器，就相当于Gearman的客户端。修改表,插入表就相当于直接下发任务。